学习笔记
知识要点总结
1. JVM基本知识
1.1 Java语言本身的特点
面向对象的基于JVM虚拟机的半编译半解释型语言， 支持GC垃圾回收，支持二进制跨平台, 生态完整，生命力强 Java相对C++, Rust等其他语言的优势和劣势： 具备比较完善的GC机制，将内存的管理和回收都由JVM完成，对象的生命周期由JVM管理，设计哲学上讲，完全不信任程序员对内存的管理行为，一方面讲，将开发者从C++那样复杂的内存管理中解放出来，能够更多关注在业务逻辑上，但是同时也引入了GC的开销，在GC使用不当情况下会影响业务效率
1.2 Java程序运行基本机制
应用开发者利用java编译器将java代码编译为字节码，每一个类对应一个字节码文件，程序运行时候首先是JVM虚拟机进程启动，作为所有Java程序的运行容器，由类装载器将类的字节码加载到内存中，加载到内存中的类就可以生成响应的对象，各个对象在特定的Java线程中运行自己的业务逻辑
1.3 字节码技术
1.3.1 字节码的作用
Java程序本质上运行机制是由JVM执行Java源文件生成的字节码，可类比C++层序运行时候是由CPU运行汇编指令来理解，字节码本质就是JVM指令的二进制表现，通常通过类似于汇编的助记符提供给开发者阅读，可以通过javap等工具将二进制字节码反编译为助记符，开发者可通过程序的字节码分析代码逻辑并定位一些性能问题，JVM的字节码操作码由一个字节表示，至多支持256中不同操作码，除了一部分留给调试使用以外，现在已经使用的JVM指令操作码大概200个左右
1.3.2 字节码分类
a. 栈操作指令，作用是操作栈帧中的栈结构和局部变量表，完成计算功能
b. 流程控制指令，完成goto, for, if等判断逻辑
c. 对象操作和方法调用指令
典型的方法调用指令:
    invokestatic 用于调用静态方法
    invokespecial 用于调用构造函数
    invokevirtual 用于对象引用调用多态
    invokeinterface 用于接口调用方法
    invokedynamic JDK7新增加，用于实现动态类型语言，lambda表达式实现的基础指令
d. 算数运算和类型转换
1.3.3 JVM执行字节码的核心内存结构
栈帧结构和load/store机制
a. 栈结构 栈结构是线程栈帧中一部分，类似于CPU中ALU的功能，用于缓存运算需要的参数，一般字节码运行时候基于栈的后入先出的机制读取参数，参数读取完之后进行弹栈，指令运行完后，如果有运行结果，将结果存储于栈顶，后面的指令从栈顶读取前面指令的运行结果，对于栈操作分为load和store两种，load类指令将局部变量表中的数值加载到栈顶，store类指令将栈顶数据弹栈并根据槽位号存储到局部变量表的对应位置
b. 局部变量表 线程栈帧的组成部分，类似于CPU中通用寄存器的功能，用于保存临时变量，每一个槽位都绑定一个局部变量，本质是内存中的一个数组，指令运行时候数据会在栈和局部变量表之间以load/store方式进行交互
1.4 类加载器原理
1.4.1 Java类的声明周期
类加载器本质功能是通过一系列步骤将字节码文件加载到JVM内存中，供JVM使用，典型的类的生存周期有7个阶段： 
加载 根据ClassPath等信息查找Class文件
验证 验证字节码文件的格式和依赖
准备 构造静态字段，方法表
解析 将符号解析为真正的引用
初始化 静态变量赋值，静态代码块执行
使用 具体线程中对类进行使用
卸载
1.4.2 类加载的场景和时机
程序入口执行静态的main方法时候，会触发main函数所在的类的加载
调用new创建类A对象时候，会触发加载类A
调用类A的静态方法时候，会触发加载类A
访问类A的静态数据字段时候，会触发加载类A
子类被加载时候会先触发其父类的加载
如果接口中实现了default方法，直接或者间接实现了该接口的类被加载时候会先触发该接口类的加载
用反射API对类进行操作时候，会触发该类的加载
初次调用MethodHandle时候，会触发该MethodHandle指向的方法所在的类的加载
1.4.3 类加载但是不初始化的场景
子类引用了父类的静态字段，会触发父类的初始化，但是不会触发子类本身的初始化
创建类A的对象数组(本质是构造引用数组), 类A会被加载，但是不会触发初始化
对常量的引用不会触发该常量所在的类的初始化，因为常量本质是存放在常量池的，其数值在编译器已经确定，不依赖于其所在类的初始化
通过类A.class方式引用A的Class对象，不会直接触发类A的初始化，除非用该Class对象实例化该类的对象或者访问了该类的静态字段或者方法
Class.forName加载指定类时候，如果initialize参数传递false，不会触发该类的初始化
通过ClassLoader默认的loadClass方法加载类，不会触发类的初始化
1.4.4 类加载器的3种分类
启动类加载器(BootstrapClassLoader) 加载JVM依赖的最核心的系统类，例如rt.jar包中的类
拓展类加载器(ExtClassLoader) 加载拓展类路径下的类
应用类加载器(AppClassLoader) 加载应用开发者自己编写的类或者jar包
1.4.5 类加载器的运行原则
双亲委托 当前级别的类加载器加载类时候会先查看其上一级的类加载器有没有加载对应的类，如果已经加载了则直接使用
类加载器的层级关系
类加载器具体实现类的继承关系
负责依赖 加载一个类时候，其依赖的所有类也必须被加载
缓存加载 对于同一个类加载器而言，其已经加载的类只会被加载一次，第二次会从缓存中读取直接使用
1.5 JMM内存模型
1.5.1 线程的内存模型
JVM线程的内存模型
线程中关于内存操作的原则：
每一个线程持有自己的栈帧，所有原生类型的局部变量都存储在每个线程自己的栈帧中，A线程的局部变量对于B线程不可见
JVM进程的堆空间对所有该JVM中的线程可见，所有线程创建的对象全部都保存在堆空间中，每一个线程都使用引用方式对堆中的对象进行访问，每一个线程对于堆中对象的引用变量也是互相独立的
对象内部的字段不论是原生字段还是引用类型，均存储在堆中
类的静态字段保存于堆中
每个线程通过引用访问同一个对象的字段时候，会在线程自己的栈中先拷贝副本，如果有修改会在修改后回写到堆中，所以两个线程同时对一个对象进行的操作，各自有各自的缓存，互相对于对方的读写行为是不可见的
1.5.2 JVM进程总体内存模型
JVM进程内存模型结构
JVM进程内存模型各组成部分：
栈Stack 用于给每个线程分配栈帧的内存空间
堆Heap 用于存放JVM进程中所有线程创建的对象，其中按照对象的生存周期状态分为新生代，老年代， 新分配的对象一般存活于Eden区，当Eden区满了，执行YnagGC时候，会将Eden中存活对象放到S区中当前活动的区域，另个S区始终保持为空，同样S区中非存活对象也会被清理掉，清理后，Eden区全部清空，S区会减少一些生命周期结束的对象，多一些内存碎片，也会多一些从Eden生存下来的对象，如果发生了S区放不下生存对象的情况下，所有生存下来对象会统一搬移到另外一个原来为空的S区去，消除内存碎片，然后两个S区倒换，交换身份；经过一定次数GC后一直生存的对象会从新生代搬移到老年代中去
非堆Non-Heap 包含CCS, CodeCache等部分, JDK8之后永久代改为Metaspace，位置移动到了非堆空间中，用于保存常量和方法的代码段等不变的信息
JMV启动参数和对应内存区域之间的关系
2. JVM中常用性能诊断工具
jps 常用jsp -lvm查看JVM进程的一些配置信息
jinfo 查看JVM进程参数信息
jstat -gc pid 定时打印GC的运行情况，可观察内存分区的容量，使用量，GC执行次数和时间
jstat -gcutil pid 以内存使用比例为单位定时打印GC运行情况
jmap -histo pid 打印JVM进程中类的实例数量以及内存占用情况
jmap -heap pid 打印堆空间分配比例和使用情况
jstack -l pid 打印JVM进程中每一个线程的调用栈和持有锁的情况
jcmd 比较综合的命令， 各种VM参数，线程参数GC状态等都可以打印
jconsole, jvisualvm, visualGV 一些图形化工具和插件，可以动态观察JVM的状态，并做一些性能分析
3. JVM中的GC
3.1 GC的一般性原理
Java中内存管理是托管给JVM进行的，开发者不需要在申请完内存之后主动进行释放操作，因此JVM内部实现了一套管理内存，回收垃圾内存的机制，以保证系统中废弃的对象占用的内存能及时得到回收，保证整个系统是有空闲内存可以使用的
传统的一种比较朴素的内存管理方式是引用计数，系统记录每一个对象被外部引用的次数，对于引用计数为0的对象判定其为垃圾对象，对其占用的内存进行回收，但是无法解决复杂依赖关系中的循环引用问题；改进的方式是引用跟踪，从当前一些一定存活的根对象出发，遍历其可达的引用对象，将遍历到的对象标记为活跃，遍历不到的对象自然认为是垃圾对象，由于循环引用的一部分对象会性能一个外部无法达到的封闭连通分量，因此通过引用跟踪的方式，标记不到这些循环引用的对象，这些对象也就自然被认为是垃圾对象，巧妙解决了循环依赖的处理问题
现代的GC一般都采用的是标记跟踪方式，总体分为3个步骤：
标记 Marking 先标记出从根对象出发可达的对象
清除 Sweeping 将未标记到的对象删除
压缩 Compack 压缩内存碎片
Stop The World机制 由于对象之间的引用关系是不断在变化的，因此为了准确标注出活动对象，需要将业务线程停止一段时间，保持对象间的引用关系不变，然后进行标注和清除工作，甚至是在压缩工作也完成之后，在恢复业务线程的运行